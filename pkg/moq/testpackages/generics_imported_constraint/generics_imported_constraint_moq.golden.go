// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package generics_imported_constraint

import (
	"context"
	"github.com/matryer/moq/pkg/moq/testpackages/generics_imported_constraint/extern"
	"github.com/matryer/moq/pkg/moq/testpackages/generics_imported_constraint/extern2"
	"io/fs"
	"sync"
)

// Ensure, that GenericStore1Mock does implement GenericStore1.
// If this is not the case, regenerate this file with moq.
var _ GenericStore1[*extern2.SomeType, *fs.PathError, fs.PathError, extern.Local, *extern2.SomeType] = &GenericStore1Mock[*extern2.SomeType, *fs.PathError, fs.PathError, extern.Local, *extern2.SomeType]{}

// GenericStore1Mock is a mock implementation of GenericStore1.
//
//	func TestSomethingThatUsesGenericStore1(t *testing.T) {
//
//		// make and configure a mocked GenericStore1
//		mockedGenericStore1 := &GenericStore1Mock{
//			EetFunc: func(ctx context.Context, handler E) error {
//				panic("mock out the Eet method")
//			},
//			FetFunc: func(ctx context.Context, handler F) error {
//				panic("mock out the Fet method")
//			},
//			JetFunc: func(ctx context.Context, handler J) error {
//				panic("mock out the Jet method")
//			},
//			LetFunc: func(ctx context.Context, handler L) error {
//				panic("mock out the Let method")
//			},
//			TetFunc: func(ctx context.Context, handler T) error {
//				panic("mock out the Tet method")
//			},
//		}
//
//		// use mockedGenericStore1 in code that requires GenericStore1
//		// and then make assertions.
//
//	}
type GenericStore1Mock[T extern.Foo1, J extern.Foo2, L extern.Foo3, F extern.Foo4, E extern.Foo5] struct {
	// EetFunc mocks the Eet method.
	EetFunc func(ctx context.Context, handler E) error

	// FetFunc mocks the Fet method.
	FetFunc func(ctx context.Context, handler F) error

	// JetFunc mocks the Jet method.
	JetFunc func(ctx context.Context, handler J) error

	// LetFunc mocks the Let method.
	LetFunc func(ctx context.Context, handler L) error

	// TetFunc mocks the Tet method.
	TetFunc func(ctx context.Context, handler T) error

	// calls tracks calls to the methods.
	calls struct {
		// Eet holds details about calls to the Eet method.
		Eet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Handler is the handler argument value.
			Handler E
		}
		// Fet holds details about calls to the Fet method.
		Fet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Handler is the handler argument value.
			Handler F
		}
		// Jet holds details about calls to the Jet method.
		Jet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Handler is the handler argument value.
			Handler J
		}
		// Let holds details about calls to the Let method.
		Let []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Handler is the handler argument value.
			Handler L
		}
		// Tet holds details about calls to the Tet method.
		Tet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Handler is the handler argument value.
			Handler T
		}
	}
	lockEet sync.RWMutex
	lockFet sync.RWMutex
	lockJet sync.RWMutex
	lockLet sync.RWMutex
	lockTet sync.RWMutex
}

// Eet calls EetFunc.
func (mock *GenericStore1Mock[T, J, L, F, E]) Eet(ctx context.Context, handler E) error {
	if mock.EetFunc == nil {
		panic("GenericStore1Mock.EetFunc: method is nil but GenericStore1.Eet was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Handler E
	}{
		Ctx:     ctx,
		Handler: handler,
	}
	mock.lockEet.Lock()
	mock.calls.Eet = append(mock.calls.Eet, callInfo)
	mock.lockEet.Unlock()
	return mock.EetFunc(ctx, handler)
}

// EetCalls gets all the calls that were made to Eet.
// Check the length with:
//
//	len(mockedGenericStore1.EetCalls())
func (mock *GenericStore1Mock[T, J, L, F, E]) EetCalls() []struct {
	Ctx     context.Context
	Handler E
} {
	var calls []struct {
		Ctx     context.Context
		Handler E
	}
	mock.lockEet.RLock()
	calls = mock.calls.Eet
	mock.lockEet.RUnlock()
	return calls
}

// Fet calls FetFunc.
func (mock *GenericStore1Mock[T, J, L, F, E]) Fet(ctx context.Context, handler F) error {
	if mock.FetFunc == nil {
		panic("GenericStore1Mock.FetFunc: method is nil but GenericStore1.Fet was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Handler F
	}{
		Ctx:     ctx,
		Handler: handler,
	}
	mock.lockFet.Lock()
	mock.calls.Fet = append(mock.calls.Fet, callInfo)
	mock.lockFet.Unlock()
	return mock.FetFunc(ctx, handler)
}

// FetCalls gets all the calls that were made to Fet.
// Check the length with:
//
//	len(mockedGenericStore1.FetCalls())
func (mock *GenericStore1Mock[T, J, L, F, E]) FetCalls() []struct {
	Ctx     context.Context
	Handler F
} {
	var calls []struct {
		Ctx     context.Context
		Handler F
	}
	mock.lockFet.RLock()
	calls = mock.calls.Fet
	mock.lockFet.RUnlock()
	return calls
}

// Jet calls JetFunc.
func (mock *GenericStore1Mock[T, J, L, F, E]) Jet(ctx context.Context, handler J) error {
	if mock.JetFunc == nil {
		panic("GenericStore1Mock.JetFunc: method is nil but GenericStore1.Jet was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Handler J
	}{
		Ctx:     ctx,
		Handler: handler,
	}
	mock.lockJet.Lock()
	mock.calls.Jet = append(mock.calls.Jet, callInfo)
	mock.lockJet.Unlock()
	return mock.JetFunc(ctx, handler)
}

// JetCalls gets all the calls that were made to Jet.
// Check the length with:
//
//	len(mockedGenericStore1.JetCalls())
func (mock *GenericStore1Mock[T, J, L, F, E]) JetCalls() []struct {
	Ctx     context.Context
	Handler J
} {
	var calls []struct {
		Ctx     context.Context
		Handler J
	}
	mock.lockJet.RLock()
	calls = mock.calls.Jet
	mock.lockJet.RUnlock()
	return calls
}

// Let calls LetFunc.
func (mock *GenericStore1Mock[T, J, L, F, E]) Let(ctx context.Context, handler L) error {
	if mock.LetFunc == nil {
		panic("GenericStore1Mock.LetFunc: method is nil but GenericStore1.Let was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Handler L
	}{
		Ctx:     ctx,
		Handler: handler,
	}
	mock.lockLet.Lock()
	mock.calls.Let = append(mock.calls.Let, callInfo)
	mock.lockLet.Unlock()
	return mock.LetFunc(ctx, handler)
}

// LetCalls gets all the calls that were made to Let.
// Check the length with:
//
//	len(mockedGenericStore1.LetCalls())
func (mock *GenericStore1Mock[T, J, L, F, E]) LetCalls() []struct {
	Ctx     context.Context
	Handler L
} {
	var calls []struct {
		Ctx     context.Context
		Handler L
	}
	mock.lockLet.RLock()
	calls = mock.calls.Let
	mock.lockLet.RUnlock()
	return calls
}

// Tet calls TetFunc.
func (mock *GenericStore1Mock[T, J, L, F, E]) Tet(ctx context.Context, handler T) error {
	if mock.TetFunc == nil {
		panic("GenericStore1Mock.TetFunc: method is nil but GenericStore1.Tet was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Handler T
	}{
		Ctx:     ctx,
		Handler: handler,
	}
	mock.lockTet.Lock()
	mock.calls.Tet = append(mock.calls.Tet, callInfo)
	mock.lockTet.Unlock()
	return mock.TetFunc(ctx, handler)
}

// TetCalls gets all the calls that were made to Tet.
// Check the length with:
//
//	len(mockedGenericStore1.TetCalls())
func (mock *GenericStore1Mock[T, J, L, F, E]) TetCalls() []struct {
	Ctx     context.Context
	Handler T
} {
	var calls []struct {
		Ctx     context.Context
		Handler T
	}
	mock.lockTet.RLock()
	calls = mock.calls.Tet
	mock.lockTet.RUnlock()
	return calls
}
